declare global  {
    type IterableOf<T> = T[] | IterableIterator<T>;
    type SplitIterablesOf<T, K extends string> = {
        [key in K]: IterableIterator<T>;
    } & {
        [IterableIterator.ALL]: IterableIterator<T>;
    };
    type GeneratorOf<T> = () => IterableOf<T>;
    interface IterableIterator<T> {
        /**
         * Returns an iterable of type X, using the given map function
         * @param mapper A function that maps an entry of type T to its corresponding type X
         */
        map<X>(mapper: (val: T) => X): IterableIterator<X>;
        /**
         * Returns an iterable that will loop only over the entries that match the given filter
         * @param filter A function that returns true if the value should be included and false if it shouldn't
         */
        filter<X = T>(filter: (val: T) => boolean): IterableIterator<X>;
        /**
         * Returns an iterable that will first loop over the entries in itself, then the entries in the given iterables
         * @param iterables The other iterables to loop over
         */
        include<X>(...iterables: Array<IterableOf<X>>): IterableIterator<T | X>;
        /**
         * Returns a value of type X, generated by iterating through the iterable and calling the reducer function for each.
         * @param reducer A function that returns a new result, taking a new entry and the result from the previous iteration, or
         * @param initialValue if it's the first iteration.
         */
        reduce<X>(reducer: (newValue: T, oldValue?: X) => X, initialValue?: T): X;
        /**
         * Returns a value of type X, generated with the given collector function.
         * @param collector A function that takes the iterable, and returns type X
         * @see `utilities/Collectors` for premade collectors
         */
        collect<X>(collector: (val: IterableIterator<T>) => X): X;
        /**
         * Returns an iterable of type X, generated with the given collector function.
         * @param collector A function that takes the iterable, and returns type X
         * @see `utilities/Collectors` for premade collectors
         */
        collect<X>(collector: (val: IterableIterator<T>) => X, iterable: true): IterableIterator<X>;
        /**
         * Loops the values of this iterable and calls the given function with each value.
         * @param user A function that takes a value. If the function returns `false`, iteration will not continue.
         */
        forEach(user: (val: T) => any): void;
        /**
         * Returns the first value in this iterator, or undefined if there are no values.
         */
        first(): T | undefined;
        /**
         * Returns the first value in this iterator.
         * @param orElse Returns this if there are no values.
         */
        first(orElse?: T): T;
        /**
         * Returns the last value in this iterator, or undefined if there are no values.
         *
         * Note: Will loop through every entry in this iterator.
         */
        last(): T | undefined;
        /**
         * Returns the last value in this iterator.
         * @param orElse Returns this if there are no values.
         *
         * Note: Will loop through every entry in this iterator.
         */
        last(orElse?: T): T;
        /**
         * Returns a random value in this iterator, or undefined if there are no values.
         *
         * Note: Will loop through every entry in this iterator.
         */
        random(): T | undefined;
        /**
         * Returns a random value in this iterator.
         * @param orElse Returns this if there are no values.
         *
         * Note: Will loop through every entry in this iterator.
         */
        random(orElse?: T): T;
        /**
         * Returns an object of iterators mapped by a splitter function.
         * @param splitter Takes a value from the iterator and returns which resulting iterator it should be part of.
         */
        split<K extends string>(splitter: (val: T) => K): SplitIterablesOf<T, K>;
        /**
         * Returns an iterator where any lower level iterables are splatted into the top layer
         */
        flat<N>(): IterableIterator<N>;
        /**
         * Returns an iterator returning only the values between `startIndex` and `endIndex`.
         * @param startIndex Inclusive
         * @param endIndex Exclusive, defaults to `Infinity` (entire iterator)
         *
         * Note: When passed negative indices, it works, but it's slower as it has to loop through
         * the entire iterable first.
         */
        slice(startIndex: number, endIndex?: number): IterableIterator<T>;
        /**
         * Returns whether at least one entry in this iterable satisfies the predicate.
         */
        anyMatch(predicate: (val: T) => boolean): boolean;
        /**
         * Returns whether all entries in this iterable satisfy the predicate.
         */
        allMatch(predicate: (val: T) => boolean): boolean;
    }
    interface RegExp {
        /**
         * Returns an iterator for the matches of this string.
         */
        matches(string: string): IterableIterator<RegExpExecArray>;
    }
    interface Array<T> {
        /**
         * Returns an iterator for the values of this array.
         * This method will be removed when it becomes native in Chromium 66+
         */
        values(): IterableIterator<T>;
        /**
         * Returns the first element in the array.
         *
         * Make a TS issue if you want to remove this helper. `[0]` doesn't want to stay indented.
         */
        first(): T;
        /**
         * Returns the last element in the array.
         *
         * Make a TS issue if you want to remove this helper. Same thing as `.first()` but also this
         * is nicer than `[this.length - 1]`
         */
        last(): T;
    }
    interface Map<K, V> {
        /**
         * Sets multiple entries in this map from an iterable of entries
         */
        setAll(entriesIterable: IterableOf<[K, V]>): void;
    }
    interface MapConstructor {
        /**
         * Creates a map from an iterable of entries
         */
        create<K, V>(entriesIterable: IterableOf<[K, V]>): Map<K, V>;
    }
    interface Function {
        callNative: Function["call"];
        applyNative: Function["apply"];
        bindNative: Function["bind"];
    }
}
/**
 * This is an empty function. The `IterableIterator` support is applied globally when this
 * module is imported--however, this module will be removed by Uglify because Uglify is
 * dumb, unless we provide something to use when importing this module. As a result, it's
 * only useful to import this module once. Currently, it is done in the module `Game`.
 */
declare function IterableIterator(): void;
declare module IterableIterator {
    const ALL: unique symbol;
}
export default IterableIterator;
export declare function Pipe<T = any>(...what: T[]): IterableIterator<T>;
export declare function isIterable(obj: any): obj is IterableOf<any>;
