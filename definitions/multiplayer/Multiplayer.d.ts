import { IConnection, IMatchmakingInfo, IMultiplayer, IMultiplayerNetworkingOptions, IMultiplayerOptions, MultiplayerSyncCheck, PacketTarget, ServerInfo } from "multiplayer/IMultiplayer";
import { IPacket } from "multiplayer/packets/IPacket";
import { TextOrTranslationData } from "newui/INewUi";
import { ICharacter } from "newui/util/Character";
import IPlayer from "player/IPlayer";
export declare const networkingOptions: IMultiplayerNetworkingOptions;
export default class Multiplayer implements IMultiplayer {
    private _playerIdentifier;
    private _matchmakingIdentifier;
    private _server;
    private _serverMatchmakingInfo;
    private _clients;
    private _joinServerTimeoutId;
    private _matchmakingServer;
    private _matchmakingRetryTimeoutId;
    private _isServer;
    private _matchmakingInfo;
    private _options;
    private _character;
    private _incomingPacketQueue;
    private _incomingPacketProcessingPaused;
    private _packetTickIntervalId;
    private _outgoingPacketQueue;
    private _currentPacketProcessing;
    private _currentSyncPacketsWaiting;
    private _currentSyncPacketsProcessing;
    private _queuedSyncPackets;
    private _syncCheckStack;
    private _activeSyncCheck;
    private _syncChecksSuppressed;
    private _disconnectingFromSyncIssue;
    constructor();
    isConnected(): boolean;
    isReady(): boolean;
    isServer(): boolean;
    isClient(): boolean;
    isProcessingPacket(): boolean;
    getDefaultOptions(): IMultiplayerOptions;
    getOptions(): IMultiplayerOptions;
    setOptions(options: IMultiplayerOptions): void;
    updateOptions(updates: Partial<IMultiplayerOptions>): void;
    getMatchmakingInfo(): IMatchmakingInfo | undefined;
    getDedicatedServerMatchmakingInfo(matchmakingServer: string): IMatchmakingInfo;
    getBannedPlayers(): string[];
    setBanned(identifier: string, ban: boolean): boolean;
    createServer(serverInfo: ServerInfo, options?: IMultiplayerOptions): void;
    joinServer(serverInfo: ServerInfo, character?: ICharacter): void;
    disconnect(reason?: TextOrTranslationData, reasonDescription?: TextOrTranslationData): Promise<void>;
    disconnectAndResetGameState(reason?: TextOrTranslationData, reasonDescription?: TextOrTranslationData): Promise<void>;
    kick(player: IPlayer, reason: TextOrTranslationData): void;
    onPlaying(): void;
    onLobbyEntered(success: boolean, lobbyId: string): void;
    getClients(): IConnection[];
    sendPacket(packet: IPacket, exclude?: PacketTarget): void;
    sendPacketTo(to: PacketTarget, packet: IPacket, force?: boolean): void;
    syncPacket(packet: IPacket, clientSide?: () => any, checkId?: boolean, waitId?: number): any;
    queueSyncPacket(packet: IPacket, clientSide?: () => any, checkId?: boolean, waitId?: number): void;
    resetSyncPacketsWaiting(): void;
    pausePacketProcessing(pause: boolean): void;
    updatePlayerId(oldPid: number, newPid: number): void;
    suppressSyncChecks(suppress: boolean): void;
    syncGameState(): void;
    isSyncCheckEnabled(syncCheck: MultiplayerSyncCheck): boolean;
    addSyncCheck(syncCheck: MultiplayerSyncCheck, value: any): void;
    addBeforeSyncChecks(packet: IPacket): void;
    addAfterSyncChecks(packet: IPacket): void;
    private addDefaultSyncChecks();
    private getPacketSyncChecks();
    private startMatchmakingServer(port);
    private stopMatchmakingServer();
    private connectMatchmakingServer(matchmakingInfo);
    private disconnectMatchmakingServer();
    private onMatchmakingServerConnected();
    private sendJoinChannelMessage();
    private clearMatchmakingRetryTimeout();
    private clearJoinServerRetryTimeout();
    private onMatchmakingServerCloseOrError(event, matchmakingInfo);
    private onMatchmakingServerMessage(event);
    private displayJoinServerRetryDialog(matchmakingInfo);
    private setupConnection(connection);
    private onIceConnectionStateChange(connection, event);
    private onNegotiationNeeded(connection, event?);
    private onDescriptionCreated(connection, description);
    private onDataChannelReceived(connection, event);
    private onDataChannelChanged(connection, event);
    private onDataChannelMessage(connection, event);
    private packetTick();
    private processIncomingPackets();
    private processOutgoingPackets();
    private processPacket(connection, packet);
    private synchronizationCheck(packet, checkBefore);
    private desync(packet, checkData, checkBefore);
    private sendPacketInternal(packet, includeConnection?, excludeConnection?, force?);
    private _sendData(connection, packet, sendNow?);
    private sendMatchmakingMessage(data, channel?);
    private closeConnection(connection);
    private onStateChange();
    private convertToMatchmakingInfo(serverInfo);
    private _parseIceCandidate(text);
}
